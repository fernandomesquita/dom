/**
 * Helper de Revisão Espaçada
 * Sistema de revisão baseado no método DOM-EARA
 * 
 * Ciclo de revisão:
 * 1. Estudo inicial (meta ESTUDO)
 * 2. Questões automáticas (meta QUESTOES) - mesmo dia
 * 3. Revisão 1ª (meta REVISAO) - 1 dia após
 * 4. Revisão Diferida 1 (meta REVISAO) - 7 dias após
 * 5. Revisão Diferida 2 (meta REVISAO) - 30 dias após
 */

import { v4 as uuidv4 } from 'uuid';
import { addDays, format } from 'date-fns';
import {
  makeOrderKey,
  formatDisplayNumber,
  getNextSuffix,
} from './metasNumeracao';

interface Meta {
  id: string;
  planoId: string;
  metaNumberBase: number;
  metaNumberSuffix: number | null;
  displayNumber: string;
  orderKey: string;
  ktreeDisciplinaId: string;
  ktreeAssuntoId: string;
  ktreeTopicoId: string | null;
  ktreeSubtopicoId: string | null;
  tipo: 'ESTUDO' | 'QUESTOES' | 'REVISAO';
  duracaoPlanejadaMin: number;
  scheduledDate: string; // ISO date
  scheduledOrder: number;
  status: string;
  autoGenerated: boolean;
  parentMetaId: string | null;
  reviewConfigJson: any;
  criadoPorId: string;
}

interface ReviewConfig {
  numeroRevisao: number; // 1, 2, 3
  diasAposEstudo: number; // 1, 7, 30
  tipoRevisao: 'PRIMEIRA' | 'DIFERIDA';
}

/**
 * Criar meta de questões automáticas
 * Executada no mesmo dia do estudo, após a meta de estudo
 */
export async function createQuestoesAutomaticas(
  db: any,
  metaEstudo: Meta,
  criadoPorId: string
): Promise<Meta> {
  // Obter próximo sufixo para a meta base
  const suffix = await getNextSuffix(db, metaEstudo.planoId, metaEstudo.metaNumberBase);
  
  const displayNumber = formatDisplayNumber(metaEstudo.metaNumberBase, suffix);
  const orderKey = makeOrderKey(metaEstudo.metaNumberBase, suffix);
  
  // Duração: 50% do tempo de estudo (mínimo 15min, máximo 60min)
  const duracaoMin = Math.min(60, Math.max(15, Math.round(metaEstudo.duracaoPlanejadaMin * 0.5)));
  
  const metaQuestoes: Partial<Meta> = {
    id: uuidv4(),
    planoId: metaEstudo.planoId,
    metaNumberBase: metaEstudo.metaNumberBase,
    metaNumberSuffix: suffix,
    displayNumber,
    orderKey,
    ktreeDisciplinaId: metaEstudo.ktreeDisciplinaId,
    ktreeAssuntoId: metaEstudo.ktreeAssuntoId,
    ktreeTopicoId: metaEstudo.ktreeTopicoId,
    ktreeSubtopicoId: metaEstudo.ktreeSubtopicoId,
    tipo: 'QUESTOES',
    duracaoPlanejadaMin: duracaoMin,
    scheduledDate: metaEstudo.scheduledDate, // Mesmo dia
    scheduledOrder: metaEstudo.scheduledOrder + 1, // Logo após o estudo
    status: 'PENDENTE',
    autoGenerated: true,
    parentMetaId: metaEstudo.id,
    reviewConfigJson: null,
    criadoPorId,
  };
  
  // Inserir no banco
  await db.query(
    `INSERT INTO metas_cronograma (
      id, plano_id, meta_number_base, meta_number_suffix, display_number, order_key,
      ktree_disciplina_id, ktree_assunto_id, ktree_topico_id, ktree_subtopico_id,
      tipo, duracao_planejada_min, scheduled_date, scheduled_order,
      status, auto_generated, parent_meta_id, criado_por_id
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [
      metaQuestoes.id,
      metaQuestoes.planoId,
      metaQuestoes.metaNumberBase,
      metaQuestoes.metaNumberSuffix,
      metaQuestoes.displayNumber,
      metaQuestoes.orderKey,
      metaQuestoes.ktreeDisciplinaId,
      metaQuestoes.ktreeAssuntoId,
      metaQuestoes.ktreeTopicoId,
      metaQuestoes.ktreeSubtopicoId,
      metaQuestoes.tipo,
      metaQuestoes.duracaoPlanejadaMin,
      metaQuestoes.scheduledDate,
      metaQuestoes.scheduledOrder,
      metaQuestoes.status,
      metaQuestoes.autoGenerated,
      metaQuestoes.parentMetaId,
      metaQuestoes.criadoPorId,
    ]
  );
  
  return metaQuestoes as Meta;
}

/**
 * Criar revisão primeira (1 dia após estudo)
 */
export async function createRevisaoPrimeira(
  db: any,
  metaEstudo: Meta,
  criadoPorId: string
): Promise<Meta> {
  const suffix = await getNextSuffix(db, metaEstudo.planoId, metaEstudo.metaNumberBase);
  
  const displayNumber = formatDisplayNumber(metaEstudo.metaNumberBase, suffix);
  const orderKey = makeOrderKey(metaEstudo.metaNumberBase, suffix);
  
  // Data: 1 dia após o estudo
  const dataEstudo = new Date(metaEstudo.scheduledDate);
  const dataRevisao = addDays(dataEstudo, 1);
  const scheduledDate = format(dataRevisao, 'yyyy-MM-dd');
  
  // Duração: 30% do tempo de estudo (mínimo 10min, máximo 30min)
  const duracaoMin = Math.min(30, Math.max(10, Math.round(metaEstudo.duracaoPlanejadaMin * 0.3)));
  
  const reviewConfig: ReviewConfig = {
    numeroRevisao: 1,
    diasAposEstudo: 1,
    tipoRevisao: 'PRIMEIRA',
  };
  
  const metaRevisao: Partial<Meta> = {
    id: uuidv4(),
    planoId: metaEstudo.planoId,
    metaNumberBase: metaEstudo.metaNumberBase,
    metaNumberSuffix: suffix,
    displayNumber,
    orderKey,
    ktreeDisciplinaId: metaEstudo.ktreeDisciplinaId,
    ktreeAssuntoId: metaEstudo.ktreeAssuntoId,
    ktreeTopicoId: metaEstudo.ktreeTopicoId,
    ktreeSubtopicoId: metaEstudo.ktreeSubtopicoId,
    tipo: 'REVISAO',
    duracaoPlanejadaMin: duracaoMin,
    scheduledDate,
    scheduledOrder: 1, // Será ajustado pela distribuição
    status: 'PENDENTE',
    autoGenerated: true,
    parentMetaId: metaEstudo.id,
    reviewConfigJson: reviewConfig,
    criadoPorId,
  };
  
  await db.query(
    `INSERT INTO metas_cronograma (
      id, plano_id, meta_number_base, meta_number_suffix, display_number, order_key,
      ktree_disciplina_id, ktree_assunto_id, ktree_topico_id, ktree_subtopico_id,
      tipo, duracao_planejada_min, scheduled_date, scheduled_order,
      status, auto_generated, parent_meta_id, review_config_json, criado_por_id
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [
      metaRevisao.id,
      metaRevisao.planoId,
      metaRevisao.metaNumberBase,
      metaRevisao.metaNumberSuffix,
      metaRevisao.displayNumber,
      metaRevisao.orderKey,
      metaRevisao.ktreeDisciplinaId,
      metaRevisao.ktreeAssuntoId,
      metaRevisao.ktreeTopicoId,
      metaRevisao.ktreeSubtopicoId,
      metaRevisao.tipo,
      metaRevisao.duracaoPlanejadaMin,
      metaRevisao.scheduledDate,
      metaRevisao.scheduledOrder,
      metaRevisao.status,
      metaRevisao.autoGenerated,
      metaRevisao.parentMetaId,
      JSON.stringify(metaRevisao.reviewConfigJson),
      metaRevisao.criadoPorId,
    ]
  );
  
  return metaRevisao as Meta;
}

/**
 * Criar revisão diferida (7 ou 30 dias após estudo)
 */
export async function createRevisaoDiferida(
  db: any,
  metaEstudo: Meta,
  numeroRevisao: 2 | 3, // 2 = 7 dias, 3 = 30 dias
  criadoPorId: string
): Promise<Meta> {
  const suffix = await getNextSuffix(db, metaEstudo.planoId, metaEstudo.metaNumberBase);
  
  const displayNumber = formatDisplayNumber(metaEstudo.metaNumberBase, suffix);
  const orderKey = makeOrderKey(metaEstudo.metaNumberBase, suffix);
  
  // Dias após estudo
  const diasApos = numeroRevisao === 2 ? 7 : 30;
  
  // Data: 7 ou 30 dias após o estudo
  const dataEstudo = new Date(metaEstudo.scheduledDate);
  const dataRevisao = addDays(dataEstudo, diasApos);
  const scheduledDate = format(dataRevisao, 'yyyy-MM-dd');
  
  // Duração: 20% do tempo de estudo (mínimo 10min, máximo 25min)
  const duracaoMin = Math.min(25, Math.max(10, Math.round(metaEstudo.duracaoPlanejadaMin * 0.2)));
  
  const reviewConfig: ReviewConfig = {
    numeroRevisao,
    diasAposEstudo: diasApos,
    tipoRevisao: 'DIFERIDA',
  };
  
  const metaRevisao: Partial<Meta> = {
    id: uuidv4(),
    planoId: metaEstudo.planoId,
    metaNumberBase: metaEstudo.metaNumberBase,
    metaNumberSuffix: suffix,
    displayNumber,
    orderKey,
    ktreeDisciplinaId: metaEstudo.ktreeDisciplinaId,
    ktreeAssuntoId: metaEstudo.ktreeAssuntoId,
    ktreeTopicoId: metaEstudo.ktreeTopicoId,
    ktreeSubtopicoId: metaEstudo.ktreeSubtopicoId,
    tipo: 'REVISAO',
    duracaoPlanejadaMin: duracaoMin,
    scheduledDate,
    scheduledOrder: 1, // Será ajustado pela distribuição
    status: 'PENDENTE',
    autoGenerated: true,
    parentMetaId: metaEstudo.id,
    reviewConfigJson: reviewConfig,
    criadoPorId,
  };
  
  await db.query(
    `INSERT INTO metas_cronograma (
      id, plano_id, meta_number_base, meta_number_suffix, display_number, order_key,
      ktree_disciplina_id, ktree_assunto_id, ktree_topico_id, ktree_subtopico_id,
      tipo, duracao_planejada_min, scheduled_date, scheduled_order,
      status, auto_generated, parent_meta_id, review_config_json, criado_por_id
    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`,
    [
      metaRevisao.id,
      metaRevisao.planoId,
      metaRevisao.metaNumberBase,
      metaRevisao.metaNumberSuffix,
      metaRevisao.displayNumber,
      metaRevisao.orderKey,
      metaRevisao.ktreeDisciplinaId,
      metaRevisao.ktreeAssuntoId,
      metaRevisao.ktreeTopicoId,
      metaRevisao.ktreeSubtopicoId,
      metaRevisao.tipo,
      metaRevisao.duracaoPlanejadaMin,
      metaRevisao.scheduledDate,
      metaRevisao.scheduledOrder,
      metaRevisao.status,
      metaRevisao.autoGenerated,
      metaRevisao.parentMetaId,
      JSON.stringify(metaRevisao.reviewConfigJson),
      metaRevisao.criadoPorId,
    ]
  );
  
  return metaRevisao as Meta;
}

/**
 * Agendar ciclo completo de revisão
 * Cria todas as metas de revisão para uma meta de estudo
 */
export async function scheduleReviewCycle(
  db: any,
  metaEstudo: Meta,
  criadoPorId: string
): Promise<{
  questoes: Meta;
  revisao1: Meta;
  revisao7: Meta;
  revisao30: Meta;
}> {
  // 1. Questões automáticas (mesmo dia)
  const questoes = await createQuestoesAutomaticas(db, metaEstudo, criadoPorId);
  
  // 2. Revisão 1ª (1 dia após)
  const revisao1 = await createRevisaoPrimeira(db, metaEstudo, criadoPorId);
  
  // 3. Revisão Diferida 1 (7 dias após)
  const revisao7 = await createRevisaoDiferida(db, metaEstudo, 2, criadoPorId);
  
  // 4. Revisão Diferida 2 (30 dias após)
  const revisao30 = await createRevisaoDiferida(db, metaEstudo, 3, criadoPorId);
  
  return {
    questoes,
    revisao1,
    revisao7,
    revisao30,
  };
}

/**
 * Verificar se meta já tem revisões agendadas
 */
export async function hasScheduledReviews(
  db: any,
  metaEstudoId: string
): Promise<boolean> {
  const result = await db.query(
    `SELECT COUNT(*) as count 
     FROM metas_cronograma 
     WHERE parent_meta_id = ? AND auto_generated = true`,
    [metaEstudoId]
  );
  
  return result[0].count > 0;
}
